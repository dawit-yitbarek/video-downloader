import puppeteer from "puppeteer";
import fs from "fs";
import path from "path";
import { NODE_ENV } from "../config/env.js";
const isProduction = NODE_ENV === "production"

// Create directory if it doesn't exist
function ensureDirExact(dirPath) {
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
    }
}

// Convert cookies to Netscape format
function toNetscape(cookies) {
    return [
        "# Netscape HTTP Cookie File",
        "# Generated by Puppeteer",
        ...cookies.map((c) => {
            const initialDot = c.domain && c.domain.startsWith(".") ? "TRUE" : "FALSE";
            return `${c.domain}\t${initialDot}\t${c.path}\t${c.secure ? "TRUE" : "FALSE"}\t${Math.floor(
                Date.now() / 1000
            ) + 31536000}\t${c.name}\t${c.value}`;
        }),
    ].join("\n");
}

// safe write file
function writeFileSafe(filePath, data) {
    const tmp = `${filePath}.tmp`;
    fs.writeFileSync(tmp, data, { encoding: "utf8" });
    fs.renameSync(tmp, filePath);
}

// Build Puppeteer launch options
function getLaunchOptions(userDataDir) {
    const baseArgs = [
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--disable-dev-shm-usage",
        "--disable-background-networking",
        "--disable-background-timer-throttling",
        "--disable-renderer-backgrounding",
    ];

    const launchOptions = {
        headless: true,
        userDataDir,
        args: baseArgs,
        defaultViewport: null
    };
    if (isProduction) {
        launchOptions.executablePath = path.resolve("./bin/chrome-linux/chrome")

    }

    return launchOptions
}

// Refresh cookies
export async function refreshCookies(dir, url, outPath) {
    let browser;
    try {
        ensureDirExact(dir);
        ensureDirExact(path.dirname(outPath));

        browser = await puppeteer.launch(getLaunchOptions(dir));
        const page = await browser.newPage();

        try {
            await page.goto(url, {
                waitUntil: "domcontentloaded",
                timeout: 60_000
            });
        } catch (err) {
            console.warn(`‚ö†Ô∏è Navigation incomplete for ${url}:`, err.message || err);
        }

        const cookies = await page.cookies();

        // SAFETY CHECK
        if (!cookies || cookies.length === 0) {
            console.warn(`‚ö†Ô∏è Extracted 0 cookies for ${url}. Existing cookie file preserved.`);
            return;
        }

        // Log cookie details for debugging
        console.log(`‚úÖ Cookies refreshed for ${url}. Count: ${cookies.length}`);
        cookies.forEach(c => {
            console.log(`- ${c.name}=${c.value} (domain=${c.domain}, path=${c.path})`);
        });

        const netscape = toNetscape(cookies);
        writeFileSafe(outPath, netscape);

    } catch (err) {
        console.error(`‚ùå Cookie refresh failed for ${url}:`, err);
    } finally {
        if (browser) {
            try {
                await browser.close();
            } catch (e) {
                console.warn("‚ö†Ô∏è Browser close failed:", e.message || e);
            }
        }
    }
}


// Manual first-login flow: LOCAL ONLY.
export async function firstLogin(dir, url) {
    if (!dir || !url) {
        console.log("Please provide both dir and url");
        return;
    }

    if (NODE_ENV === "production") {
        throw new Error("firstLogin must not run in production. Run it locally to create a userDataDir and then deploy that profile.");
    }

    ensureDirExact(dir);

    let browser;
    try {
        browser = await puppeteer.launch({ headless: false, userDataDir: dir, defaultViewport: null });
        const page = await browser.newPage();
        await page.goto(url, { waitUntil: "domcontentloaded", timeout: 120_000 });

        console.log(`üëâ Please log in manually in the opened ${url} window. Close the browser when finished.`);

        await new Promise((resolve) => browser.on("disconnected", resolve));

        console.log("‚úÖ Browser closed ‚Äî session (profile) saved locally.");
    } catch (err) {
        console.error(`‚ùå Failed to start first login for ${url}:`, err);
    } finally {
        if (browser) {
            try {
                await browser.close();
            } catch (e) { }
        }
    }
}